LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL; -- Use for arithmetic operations

ENTITY ALU_3 IS
	PORT (
    	clock : IN std_logic;                         -- Clock signal
    	res   : IN std_logic;                         -- Reset signal
    	A     : IN unsigned(7 downto 0);              -- First operand as unsigned
    	B     : IN unsigned(7 downto 0);              -- Second operand as unsigned
    	OP    : IN std_logic_vector(15 downto 0);     -- 16-bit opcode input
    	neg   : OUT std_logic;                        -- Negative flag output
    	R1    : OUT std_logic_vector(3 downto 0);     -- Output R1 (upper nibble)
    	R2    : OUT std_logic_vector(3 downto 0)      -- Output R2 (lower nibble)
	);
END ALU_3;

ARCHITECTURE Behavior OF ALU_3 IS
	SIGNAL Reg1, Reg2, Result : unsigned(7 downto 0); -- Temporary signals for calculations
BEGIN
	PROCESS (clock, res)
	BEGIN
    	IF res = '1' THEN
        	Result <= (others => '0'); -- Reset the output on reset signal
    	ELSIF rising_edge(clock) THEN
        	Reg1 <= A; -- Store input A into Reg1
        	Reg2 <= B; -- Store input B into Reg2

        	CASE OP IS
                -- Function 1: Replace even bits of A with corresponding bits of B
            	WHEN "1000000000000000" =>  
                	Result <= (B(6) & A(7) & B(4) & A(5) & B(2) & A(3) & B(0) & A(1));  
            	-- Function 2: Produce A NOR B
            	WHEN "0100000000000000" =>  
                	Result <= not (Reg1 or Reg2);  
            	-- Function 3: Add A and B, then multiply by 2
            	WHEN "0010000000000000" =>  
                	Result <= (Reg1 + Reg2) sll 1;  
            	-- Function 4: Swap the upper and lower nibbles of B
            	WHEN "0001000000000000" =>  
                	Result <= (Reg2(3 downto 0) & Reg2(7 downto 4));  
            	-- Function 5: XOR the even bits of A and B
            	WHEN "0000100000000000" =>  
                	Result <= ("0" & A(6) xor B(6) & "0" & A(4) xor B(4) & "0" & A(2) xor B(2) & "0" & A(0) xor B(0));  
            	-- Function 6: Shift B to the right by 2 bits, input bit = '0' (SHR)
            	WHEN "0000010000000000" =>  
                	Result <= ("00" & Reg2(7 downto 2));  
            	-- Function 7: Set output to null (zero)
            	WHEN "0000001000000000" =>  
                	Result <= (others => '0');  
            	-- Function 8: 2's complement of A
            	WHEN "0000000100000000" =>  
                	Result <= unsigned(-signed(Reg1));  
            	-- Default case: Zero output
            	WHEN OTHERS =>  
                	Result <= (others => '0');  
        	END CASE;  
    	END IF;  
	END PROCESS;  

	-- Assign Most Significant Nibble and Least Significant Nibble
	R1 <= std_logic_vector(Result(7 downto 4));  -- Convert upper nibble of result for R1 output
	R2 <= std_logic_vector(Result(3 downto 0));  -- Convert lower nibble of result for R2 output

	-- Set Negative flag based on the sign of the result
	neg <= '1' WHEN signed(Result) < 0 ELSE '0';  

END Behavior;

